<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LRU Cache with Fixed Blocks & Stack</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .simulator-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 968px) {
            .simulator-container {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .panel h2 {
            color: #4a5568;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #4a5568;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 5px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }

        .cache-visualization, .stack-visualization {
            min-height: 350px;
            border: 2px dashed #cbd5e0;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .cache-visualization h3, .stack-visualization h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #4a5568;
        }

        .cache-blocks-container, .stack-blocks {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            gap: 15px;
        }

        .cache-block-row {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }

        .cache-index {
            width: 60px;
            height: 40px;
            background: #4a5568;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 5px;
        }

        .cache-block {
            flex: 1;
            height: 60px;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.5s ease;
            min-width: 80px;
        }

        .stack-blocks {
            justify-content: flex-start;
            gap: 10px;
        }

        .stack-block {
            width: 80px;
            height: 50px;
            background: #ed8936;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }

        .cache-block.empty {
            background: #e2e8f0;
            color: #a0aec0;
            font-style: italic;
        }

        .cache-block.new {
            background: #48bb78;
            transform: scale(1.05);
            box-shadow: 0 0 0 3px rgba(72, 187, 120, 0.5);
        }

        .cache-block.evicted {
            background: #f56565;
            transform: scale(0.95);
            opacity: 0.7;
        }

        .cache-block.hit {
            background: #38a169;
            animation: pulse 0.5s;
        }

        .stack-block.hit {
            background: #38a169;
            animation: pulse 0.5s;
        }

        .stack-block.evicted {
            background: #f56565;
            text-decoration: line-through;
            opacity: 0.7;
        }

        .status-info {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            padding: 10px 15px;
            background: #f7fafc;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            flex: 1;
            min-width: 150px;
        }

        .status-item h3 {
            font-size: 0.9rem;
            color: #718096;
            margin-bottom: 5px;
        }

        .status-item p {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4a5568;
        }

        .hit {
            color: #48bb78;
        }

        .miss {
            color: #f56565;
        }

        .history-log {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            padding: 15px;
            background: #f7fafc;
        }

        .log-entry {
            padding: 10px;
            border-bottom: 1px solid #e2e8f0;
            font-family: 'Courier New', monospace;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-hit {
            background: #f0fff4;
            color: #48bb78;
        }

        .log-miss {
            background: #fff5f5;
            color: #f56565;
        }

        .explanation {
            margin-top: 30px;
        }

        .explanation h3 {
            color: white;
            margin-bottom: 15px;
        }

        .explanation-content {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 20px;
        }

        .explanation-content p {
            margin-bottom: 15px;
        }

        .explanation-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .explanation-content li {
            margin-bottom: 8px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #718096;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .operation-explanation {
            margin-top: 15px;
            padding: 10px;
            background: #f7fafc;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            font-size: 0.9rem;
        }

        .stack-labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
        }

        .lru-pointer {
            position: absolute;
            right: -30px;
            font-weight: bold;
            color: #e53e3e;
            font-size: 1.2rem;
        }

        .cache-index-label {
            display: block;
            text-align: center;
            font-size: 0.8rem;
            color: #718096;
            margin-top: 5px;
        }

        .memory-block {
            display: inline-block;
            padding: 2px 8px;
            background: #c6f6d5;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            margin: 0 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LRU Cache with Fixed Blocks & Stack</h1>
            <p>Visualize LRU cache replacement with fixed memory blocks and LRU stack tracking</p>
        </div>

        <div class="simulator-container">
            <div class="panel">
                <h2>Configuration</h2>
                <div class="input-group">
                    <label for="cacheSize">Cache Size (Number of Blocks)</label>
                    <input type="number" id="cacheSize" min="1" max="10" value="4">
                </div>
                <div class="input-group">
                    <label for="referenceSequence">Reference Sequence (comma-separated)</label>
                    <input type="text" id="referenceSequence" value="7, 0, 1, 2, 0, 3, 5, 4, 2, 3, 0">
                </div>
                <div class="button-group">
                    <button class="btn-primary" id="initializeBtn">Initialize</button>
                    <button class="btn-success" id="nextStepBtn">Next Step</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                    <button class="btn-primary" id="autoRunBtn">Auto Run</button>
                </div>
            </div>

            <div class="panel">
                <h2>Cache Memory & LRU Stack</h2>
                <div class="visualization-container">
                    <div class="cache-visualization">
                        <h3>Cache Memory (Fixed Blocks)</h3>
                        <div class="cache-blocks-container" id="cacheBlocks">
                            <!-- Cache blocks will be dynamically inserted here -->
                        </div>
                        <div class="cache-index-label">Each block stays in its fixed position until replaced</div>
                    </div>
                    <div class="stack-visualization">
                        <h3>LRU Stack (Top = MRU, Bottom = LRU)</h3>
                        <div class="stack-blocks" id="stackBlocks">
                            <!-- Stack blocks will be dynamically inserted here -->
                        </div>
                        <div class="stack-labels">
                            <div class="cache-label">Bottom (Next to Evict)</div>
                            <div class="cache-label">Top (Most Recent)</div>
                        </div>
                    </div>
                </div>
                <div class="status-info">
                    <div class="status-item">
                        <h3>Current Block</h3>
                        <p id="currentBlock">None</p>
                    </div>
                    <div class="status-item">
                        <h3>Result</h3>
                        <p id="result">None</p>
                    </div>
                    <div class="status-item">
                        <h3>LRU Block</h3>
                        <p id="lruBlock">None</p>
                    </div>
                </div>
                <div class="operation-explanation" id="operationExplanation">
                    The simulation is ready. Click "Next Step" to begin.
                </div>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="hitCount">0</div>
                        <div class="stat-label">Hits</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="missCount">0</div>
                        <div class="stat-label">Misses</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="hitRate">0%</div>
                        <div class="stat-label">Hit Rate</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>History Log</h2>
            <div class="history-log" id="historyLog">
                <!-- Log entries will be dynamically inserted here -->
            </div>
        </div>

        <div class="explanation">
            <h3>How LRU Cache with Fixed Blocks Works</h3>
            <div class="explanation-content">
                <p>The <strong>Least Recently Used (LRU)</strong> algorithm with fixed cache blocks:</p>
                <ul>
                    <li><strong>Cache Memory</strong>: Has fixed positions (b0, b1, b2, b3). Once a memory block is placed in a cache block, it stays there until it becomes the LRU and gets replaced.</li>
                    <li><strong>LRU Stack</strong>: Tracks the recency order of blocks in cache. Bottom of stack = LRU (next to evict), Top of stack = MRU (most recent).</li>
                    <li><strong>Hit</strong>: Block found in cache. LRU stack is updated - block moves to top (MRU). Cache memory remains unchanged.</li>
                    <li><strong>Miss</strong>: Block not in cache.
                        <ul>
                            <li>If cache has empty block: Block placed in empty position, added to top of LRU stack.</li>
                            <li>If cache is full: LRU block (bottom of stack) is evicted from its cache position, new block takes that position, and moves to top of LRU stack.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Example</strong>: After sequence <span class="memory-block">7</span>, <span class="memory-block">0</span>, <span class="memory-block">1</span>, <span class="memory-block">2</span>, cache might be: b0=7, b1=0, b2=1, b3=2. LRU stack: [7, 0, 1, 2] (7=LRU, 2=MRU). When <span class="memory-block">0</span> is accessed again: It's a HIT. Cache stays same, but LRU stack becomes: [7, 1, 2, 0] (0 moves to MRU position).</p>
            </div>
        </div>
    </div>

    <script>
        class LRUCacheSimulator {
            constructor() {
                this.cacheSize = 4;
                this.sequence = [7, 0, 1, 2, 0, 3, 5, 4, 2, 3, 0];
                // Cache memory: array of objects {block: number, index: number}
                this.cacheMemory = []; // Fixed positions, each can hold a block or be empty
                this.lruStack = []; // Tracks recency order of blocks currently in cache
                this.currentStep = 0;
                this.hitCount = 0;
                this.missCount = 0;
                this.autoRunInterval = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.initialize();
            }
            
            initializeElements() {
                this.cacheSizeInput = document.getElementById('cacheSize');
                this.sequenceInput = document.getElementById('referenceSequence');
                this.initializeBtn = document.getElementById('initializeBtn');
                this.nextStepBtn = document.getElementById('nextStepBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.autoRunBtn = document.getElementById('autoRunBtn');
                this.cacheBlocks = document.getElementById('cacheBlocks');
                this.stackBlocks = document.getElementById('stackBlocks');
                this.currentBlockEl = document.getElementById('currentBlock');
                this.resultEl = document.getElementById('result');
                this.lruBlockEl = document.getElementById('lruBlock');
                this.operationExplanationEl = document.getElementById('operationExplanation');
                this.historyLog = document.getElementById('historyLog');
                this.hitCountEl = document.getElementById('hitCount');
                this.missCountEl = document.getElementById('missCount');
                this.hitRateEl = document.getElementById('hitRate');
            }
            
            setupEventListeners() {
                this.initializeBtn.addEventListener('click', () => this.initialize());
                this.nextStepBtn.addEventListener('click', () => this.nextStep());
                this.resetBtn.addEventListener('click', () => this.initialize());
                this.autoRunBtn.addEventListener('click', () => this.toggleAutoRun());
            }
            
            initialize() {
                try {
                    this.cacheSize = parseInt(this.cacheSizeInput.value);
                    const sequenceStr = this.sequenceInput.value;
                    this.sequence = sequenceStr.split(',').map(x => parseInt(x.trim()));
                    this.currentStep = 0;
                    
                    // Initialize empty cache memory with fixed positions
                    this.cacheMemory = [];
                    for (let i = 0; i < this.cacheSize; i++) {
                        this.cacheMemory.push({index: i, block: null});
                    }
                    
                    this.lruStack = [];
                    this.hitCount = 0;
                    this.missCount = 0;
                    
                    this.stopAutoRun();
                    
                    this.historyLog.innerHTML = '';
                    this.addLogEntry("Initialized LRU Cache Simulation");
                    this.addLogEntry(`Cache Size: ${this.cacheSize} blocks (b0 to b${this.cacheSize-1})`);
                    this.addLogEntry(`Reference Sequence: ${this.sequence.join(', ')}`);
                    this.addLogEntry("----------------------------------------");
                    
                    this.currentBlockEl.textContent = 'None';
                    this.resultEl.textContent = 'None';
                    this.resultEl.className = '';
                    this.lruBlockEl.textContent = 'None';
                    this.operationExplanationEl.textContent = 'The simulation is ready. Click "Next Step" to begin.';
                    
                    this.updateStats();
                    this.drawCache();
                    this.drawStack();
                    
                } catch (error) {
                    alert('Please enter valid numbers for cache size and sequence');
                }
            }
            
            nextStep() {
                if (this.currentStep >= this.sequence.length) {
                    alert('All reference blocks have been processed.');
                    this.stopAutoRun();
                    return;
                }
                
                const requestedBlock = this.sequence[this.currentStep];
                this.currentBlockEl.textContent = requestedBlock;
                
                let result, operation, explanation, evictedBlock = null;
                let cachePosition = -1;
                
                // Check if block is in cache
                const blockInCache = this.cacheMemory.findIndex(item => item.block === requestedBlock);
                const blockInStack = this.lruStack.indexOf(requestedBlock);
                
                if (blockInCache !== -1) {
                    // HIT: Block found in cache
                    result = 'HIT';
                    this.hitCount++;
                    
                    // Update LRU stack: move block to top (MRU)
                    if (blockInStack !== -1) {
                        this.lruStack.splice(blockInStack, 1);
                    }
                    this.lruStack.push(requestedBlock);
                    
                    operation = 'Cache Hit';
                    explanation = `Block ${requestedBlock} found in cache at position b${blockInCache}. LRU stack updated: ${requestedBlock} moved to top (MRU position).`;
                    
                } else {
                    // MISS: Block not in cache
                    result = 'MISS';
                    this.missCount++;
                    
                    // Find an empty cache position
                    let emptyPosition = this.cacheMemory.findIndex(item => item.block === null);
                    
                    if (emptyPosition !== -1) {
                        // Cache has empty space: place block in empty position
                        this.cacheMemory[emptyPosition].block = requestedBlock;
                        cachePosition = emptyPosition;
                        this.lruStack.push(requestedBlock);
                        
                        operation = 'Cache Miss - Fill Empty Block';
                        explanation = `Block ${requestedBlock} not in cache. Placed in empty position b${emptyPosition}. Added to top of LRU stack.`;
                        
                    } else {
                        // Cache is full: need to evict LRU block
                        const lruBlock = this.lruStack[0]; // Bottom of stack is LRU
                        
                        // Find and evict LRU block from cache
                        const lruPosition = this.cacheMemory.findIndex(item => item.block === lruBlock);
                        if (lruPosition !== -1) {
                            evictedBlock = lruBlock;
                            this.cacheMemory[lruPosition].block = requestedBlock;
                            cachePosition = lruPosition;
                            
                            // Update LRU stack: remove LRU block, add new block to top
                            this.lruStack.shift(); // Remove LRU from bottom
                            this.lruStack.push(requestedBlock); // Add new to top
                            
                            operation = 'Cache Miss - Replace LRU';
                            explanation = `Block ${requestedBlock} not in cache. Cache full. Evicted LRU block ${evictedBlock} from position b${lruPosition} and replaced with ${requestedBlock}.`;
                        }
                    }
                }
                
                this.resultEl.textContent = result;
                this.resultEl.className = result === 'HIT' ? 'hit' : 'miss';
                
                // Update LRU block display
                const currentLruBlock = this.lruStack.length > 0 ? this.lruStack[0] : 'None';
                this.lruBlockEl.textContent = currentLruBlock === 'None' ? 'None' : `Block ${currentLruBlock}`;
                
                this.operationExplanationEl.textContent = explanation;
                
                // Log this step
                const cacheState = this.cacheMemory.map((item, idx) => 
                    item.block !== null ? `b${idx}=${item.block}` : `b${idx}=empty`
                ).join(', ');
                
                const stackState = this.lruStack.length > 0 ? `[${this.lruStack.join(' ← ')}]` : '[]';
                const logEntry = `Step ${this.currentStep + 1}: Block ${requestedBlock} → ${result}, Cache: ${cacheState}, LRU Stack: ${stackState}`;
                this.addLogEntry(logEntry, result === 'HIT' ? 'log-hit' : 'log-miss');
                
                this.updateStats();
                this.drawCache(requestedBlock, result === 'HIT', evictedBlock, cachePosition);
                this.drawStack(requestedBlock, result === 'HIT', evictedBlock);
                this.currentStep++;
            }
            
            toggleAutoRun() {
                if (this.autoRunInterval) {
                    this.stopAutoRun();
                    this.autoRunBtn.textContent = 'Auto Run';
                    this.autoRunBtn.classList.remove('btn-secondary');
                    this.autoRunBtn.classList.add('btn-primary');
                } else {
                    this.autoRunBtn.textContent = 'Stop Auto Run';
                    this.autoRunBtn.classList.remove('btn-primary');
                    this.autoRunBtn.classList.add('btn-secondary');
                    this.autoRunInterval = setInterval(() => {
                        if (this.currentStep >= this.sequence.length) {
                            this.stopAutoRun();
                            return;
                        }
                        this.nextStep();
                    }, 1500);
                }
            }
            
            stopAutoRun() {
                if (this.autoRunInterval) {
                    clearInterval(this.autoRunInterval);
                    this.autoRunInterval = null;
                }
            }
            
            addLogEntry(message, className = '') {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${className}`;
                logEntry.textContent = message;
                this.historyLog.appendChild(logEntry);
                this.historyLog.scrollTop = this.historyLog.scrollHeight;
            }
            
            updateStats() {
                this.hitCountEl.textContent = this.hitCount;
                this.missCountEl.textContent = this.missCount;
                
                const total = this.hitCount + this.missCount;
                const hitRate = total > 0 ? (this.hitCount / total * 100).toFixed(1) : 0;
                this.hitRateEl.textContent = `${hitRate}%`;
            }
            
            drawCache(newBlock = null, isHit = false, evictedBlock = null, newPosition = -1) {
                this.cacheBlocks.innerHTML = '';
                
                this.cacheMemory.forEach((item, index) => {
                    const row = document.createElement('div');
                    row.className = 'cache-block-row';
                    
                    // Cache index (b0, b1, etc.)
                    const indexEl = document.createElement('div');
                    indexEl.className = 'cache-index';
                    indexEl.textContent = `b${index}`;
                    row.appendChild(indexEl);
                    
                    // Cache block content
                    const blockEl = document.createElement('div');
                    blockEl.className = 'cache-block';
                    
                    if (item.block === null) {
                        blockEl.textContent = 'Empty';
                        blockEl.classList.add('empty');
                    } else {
                        blockEl.textContent = item.block;
                        
                        // Highlight if this is the new block
                        if (newBlock !== null && item.block === newBlock && index === newPosition) {
                            blockEl.classList.add(isHit ? 'hit' : 'new');
                        }
                        
                        // Highlight if this block was evicted
                        if (evictedBlock !== null && item.block === evictedBlock) {
                            blockEl.classList.add('evicted');
                        }
                    }
                    
                    row.appendChild(blockEl);
                    this.cacheBlocks.appendChild(row);
                });
            }
            
            drawStack(newBlock = null, isHit = false, evictedBlock = null) {
                this.stackBlocks.innerHTML = '';
                
                if (this.lruStack.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.textContent = 'Stack is empty';
                    emptyMsg.style.color = '#718096';
                    emptyMsg.style.fontStyle = 'italic';
                    this.stackBlocks.appendChild(emptyMsg);
                    return;
                }
                
                // Draw stack from bottom (LRU) to top (MRU)
                for (let i = 0; i < this.lruStack.length; i++) {
                    const block = this.lruStack[i];
                    const blockEl = document.createElement('div');
                    blockEl.className = 'stack-block';
                    blockEl.textContent = block;
                    
                    // Highlight if this is the new block
                    if (newBlock !== null && block === newBlock) {
                        blockEl.classList.add(isHit ? 'hit' : 'new');
                    }
                    
                    // Highlight if this block was evicted
                    if (evictedBlock !== null && block === evictedBlock) {
                        blockEl.classList.add('evicted');
                    }
                    
                    // Add position indicator
                    if (i === 0) {
                        blockEl.title = 'Bottom of Stack (LRU - Next to evict)';
                    } else if (i === this.lruStack.length - 1) {
                        blockEl.title = 'Top of Stack (MRU - Most recent)';
                    }
                    
                    this.stackBlocks.appendChild(blockEl);
                }
            }
        }
        
        // Initialize the simulator when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new LRUCacheSimulator();
        });
    </script>
</body>
</html>